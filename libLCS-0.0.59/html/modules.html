<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
	<title>
		libLCS - A Logic Circuit Simulation Library in C++
	</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<body>
<br>
<center>
<table>
	<tr>
		<td>
			<img src = "logo.jpg">
		</td>
		<td>
			<h1> - A Logic Circuit Simulation Library in C++</h1>
		</td>
	</tr>
</table>
</center>

<br><br>

<div class = "tabs">
<ul>
	<li><a class = "el" href = "index.html"><span>Home</span></a></li>
	<li><a class = "el" href = "news.html"><span>News</span></a></li>
	<li><a class = "el" href = "examples.html"><span>Examples</span></a></li>
	<li><a class = "el" href = "userguide.html"><span>Userguide</span></a></li>
	<li><a class = "el" href = "devguide.html"><span>Developer Guide</span></a></li>
	<li><a class = "el" href = "download.html"><span>Download</span></a></li>
	<li><a class = "el" href = "install.html"><span>Install</span></a></li>
	<li><a class = "el" href = "links.html"><span>Links</span></a></li>
	<li><a class = "el" href = "archives.html"><span>Archives</span></a></li>
</ul>
</div>

<br><br>

<!-- Generated by Doxygen 1.4.7 -->
<h1><a class="anchor" name="modules">Building Custom Modules</a></h1><hr>
<p>
In the Verilog hardware description language, modules are omni present and are required to perform a simulation, however simple the system be. libLCS does not require that a user <em>has</em> to define a module. As presented in the <a class="el" href="getting_started.html">getting started</a> section, one can use the off-the-shelf logic gates to build his/her system and perform a simulation. However, such an approach is suitable only for building small and simple systems. As the system grows in size and complexity, building it using the off-the-shelf logic gates and modules gets very laborious and error prone. One should follow a <em>Top-Down</em> design approach and build modules which consist of other simpler sub modules. Sometimes, as the system gets complex, simulating/testing the algorithm becomes more important than the actual gate-level circuit. For this, one would need to build modules which are functional equivalents of the actual gate-level circuit (Such a simulation is called as <em>data flow modelling</em> in Verilog). libLCS provides ways to build functional modules, as well as build modules consisting of other sub modules.<p>
<h2>The different kinds of modules in libLCS</h2>
<p>
Using libLCS, one can build two different kinds of modules: 1. <b>Block-Level Modules</b> and 2. <b> Functional Modules</b>. Block-level modules are ones which are internally a connected ensemble of other modules. They serve merely as an encapsulation of existsing modules into a larger module. Building block-level modules does not require any special care as one only needs to initialise the sub-modules (and connect them up suitably) in the constructor of the module class. These sub-modules will have to be destroyed in the destructor of the module class. Examples of building one's own block-level modules can be found <a class="el" href="examples.html#block_level_modules_examples">here</a>. I shall not discuss building of block level modules in much more detail. Further in this section, I shall only discuss building functional modules in detail. <br>
<p>
<hr>
<h2><a class="anchor" name="functional_modules_guide">
Functional Modules</a></h2>
[To understand the material presented below in a better/quicker fashion, use <a class="el" href="one_bit_fa_functional_module.html">this</a> as a reference implementation of the points discussed.]<p>
Functional modules are ones which do not internally have other sub-modules. They merely read the input busses lines and set the output bus lines accordingly. They have to be built with proper care, following <a class="el" href="module_checklist_topic_guide.html">certain rules</a>. To get a quick picture on how a functional module differs from a block-level module, compare the <a class="el" href="one_bit_fa_gate_level_module.html">block-level realisation</a> and, the <a class="el" href="one_bit_fa_functional_module.html">functional realisation</a> examples of a 1-bit full-adder module. In this section, I shall discuss the concepts involved in building one's own functional modules. The first rule for implementing a functional module class is to derive it from the class <code><a class="el" href="classlcs_1_1_module.html">lcs::Module</a></code>.<p>
<h4>Input Busses of Functional Modules</h4>
<p>
Every module, functional or block-level, will have a set of input busses, and set of output busses. In case of functional modules, the module implementer should ensure that the input busses drive the module. For this, the input busses to a functional module should be of the class <code><a class="el" href="classlcs_1_1_input_bus.html">lcs::InputBus</a></code>. Busses of class <code><a class="el" href="classlcs_1_1_input_bus.html">lcs::InputBus</a></code> allow registration by a module to be driven by the bus. Getting driven by a bus is equivalent to being notified of one of the following three possible line events which can occur on the bus lines.<p>
<ol>
<li>
Line State Change </li>
<li>
Line Positive Edge </li>
<li>
Line Negative Edge </li>
</ol>
<p>
In libLCS, the above events are provided as enumerations under the enumerated type <code><a class="el" href="namespacelcs.html#0c92d7059f3337c568d3a245248cc498">lcs::LineEvent</a></code>. Module implementers should register the module with the input busses so that the module will be notified of the line events occuring on input busses as relevant. For example, an AND gate module should register to be notified of a line state change event on any of its input lines. Similarly, a positive-edge triggered D-flipflop module should register to be notifed of an occurance of a line positive edge event on its clock input. Registering to be notified of line events is done through the function <code><a class="el" href="classlcs_1_1_input_bus.html#866415417a5bed73a34ae3960e7d0d82">lcs::InputBus::notify</a></code>. The prototype of this function is as follows.<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="classlcs_1_1_input_bus.html#866415417a5bed73a34ae3960e7d0d82">lcs::InputBus::notify</a>(<a class="code" href="classlcs_1_1_module.html">lcs::Module</a> *mod, <span class="keyword">const</span> <a class="code" href="namespacelcs.html#0c92d7059f3337c568d3a245248cc498">lcs::LineEvent</a> &amp;event, 
                           <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;portId, <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;line = -1) throw (lcs::OutOfRangeException&lt;<span class="keywordtype">int</span>&gt;);
</pre></div><p>
A call to <code><a class="el" href="classlcs_1_1_input_bus.html#866415417a5bed73a34ae3960e7d0d82">lcs::InputBus::notify</a></code> should be made in the constructor of the functional module class. The first argument should be the pointer to the module object being registered with the bus. In a module class constructor, it should be the <b><code>this</code> </b> argument. The second argument should be the line event which the bus should notify the module of. The third argument is the integer id of the port to which the bus is connected to. The last argument indicates the index of the line in the bus, occurrance of an event on which the module is seeking to be notified of. If a negative value is passed as the last argument, all the lines in the bus will notify the module of line the event whenever it occurs. If a value beyond the allowed line index for the bus is passed, then an <code>lcs::OutOfRangeException&lt;int&gt;</code> is thrown.<p>
When a module ceases to exist in the simulation space, it cannot be notified by the input busses with which it has registered. Hence, in the destructor of the module class, the module should de-register itself with all input busses from being driven by them. This is done by calling the function <code><a class="el" href="classlcs_1_1_input_bus.html#23fbbe858f25a35b9957923ee52edc21">lcs::InputBus::stopNotification</a></code> for all the input busses. The parameters to this function should exactly be the same, and in the same order, as they were when the module was registering itself to be notified by the bus using the function <code><a class="el" href="classlcs_1_1_input_bus.html#866415417a5bed73a34ae3960e7d0d82">lcs::InputBus::notify</a></code>.<p>
<b>NOTE:</b> Objects of the class <code><a class="el" href="classlcs_1_1_input_bus.html">lcs::InputBus</a></code> are readonly busses. There is no way one can set the lines states of these busses. It has been designed this way as the module to which these objects are input busses have no business to set their line states. In Verilog, this feature is incorporated by restricting module inputs to be of type <code>wire</code> only.<p>
<h4>Output Busses of Functional Modules</h4>
<p>
A module processes the input signals (which are available on input bus lines) and sets the output bus lines accordingly. This requires that the output busses be of a type which allows setting the bus lines. Such a bus class is available in in libLCS as <code><a class="el" href="classlcs_1_1_bus.html">lcs::Bus</a></code>. Hence, all output busses of functional modules should be of type <code><a class="el" href="classlcs_1_1_bus.html">lcs::Bus</a></code>.<p>
[<b>NOTE</b>: Assignment delays can be associated with busses of type <code><a class="el" href="classlcs_1_1_bus.html">lcs::Bus</a></code>. Read more on this <a class="el" href="delays.html">here</a>.]<p>
<h4>Overriding the functions <code><a class="el" href="classlcs_1_1_module.html#7e0c94b92b58ae869d7663b16c566a7d">lcs::Module::onStateChange</a></code>, <code><a class="el" href="classlcs_1_1_module.html#0d85c2fcb6991b21b01a7a6294d69935">lcs::Module::onPosEdge</a></code>, <code><a class="el" href="classlcs_1_1_module.html#34f9d177a907cd720b7426afba6e4dfd">lcs::Module::onNegEdge</a></code> </h4>
<p>
As mentioned above, all functional modules should be a derivative of the class <code><a class="el" href="classlcs_1_1_module.html">lcs::Module</a></code>. Apart from ensuring that the modules register with the input busses to be notified of input line events, module implementers should override the virtual member functions of the class <code><a class="el" href="classlcs_1_1_module.html">lcs::Module</a></code> as neccessary. For example, an AND gate module should override the <code><a class="el" href="classlcs_1_1_module.html#7e0c94b92b58ae869d7663b16c566a7d">lcs::Module::onStateChange</a></code> function, while a positive edge triggered D-flipflop module should override the function <code><a class="el" href="classlcs_1_1_module.html#0d85c2fcb6991b21b01a7a6294d69935">lcs::Module::onPosEdge</a></code>. These are the functions using which the input busses will notify the module of the line events. These functions are the main work horses of the module classes. When notified of a line event, they should take the action corresponding to the event which triggered them. Typically, such action involves processing the line states of the input busses and setting the output bus states accordingly. <hr>
<center>
	Copyright &copy 2006, 2007 Siva Chandra <br>
	<img src = "logo_small.jpg">
</center>
</body>
</html>

