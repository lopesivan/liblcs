<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
	<title>
		libLCS - A Logic Circuit Simulation Library in C++
	</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<body>
<br>
<center>
<table>
	<tr>
		<td>
			<img src = "logo.jpg">
		</td>
		<td>
			<h1> - A Logic Circuit Simulation Library in C++</h1>
		</td>
	</tr>
</table>
</center>

<br><br>

<div class = "tabs">
<ul>
	<li><a class = "el" href = "index.html"><span>Home</span></a></li>
	<li><a class = "el" href = "news.html"><span>News</span></a></li>
	<li><a class = "el" href = "examples.html"><span>Examples</span></a></li>
	<li><a class = "el" href = "userguide.html"><span>Userguide</span></a></li>
	<li><a class = "el" href = "devguide.html"><span>Developer Guide</span></a></li>
	<li><a class = "el" href = "download.html"><span>Download</span></a></li>
	<li><a class = "el" href = "install.html"><span>Install</span></a></li>
	<li><a class = "el" href = "links.html"><span>Links</span></a></li>
	<li><a class = "el" href = "archives.html"><span>Archives</span></a></li>
</ul>
</div>

<br><br>

<!-- Generated by Doxygen 1.4.7 -->
<h1><a class="anchor" name="getting_started">Getting Started With libLCS</a></h1><hr>
<p>
The easiest way to get started with libLCS is to start building simple circuits using the off-the-shelf logic gates provided in libLCS. All circuit elements, which have an input and an output, will be called as <b>modules</b> when reffered to in the context of libLCS. Since logic gates have a well defined input and output, they are also called as modules in libLCS (unlike in Verilog where logic gates are reffered to as <em>primitives</em>). All logic gate modules (except the NOT gate module) in libLCS are provided as class templates requiring two template parameters. The template parameter first in the order of template arguments denotes the number of inputs to the gate, and the other template parameter denotes the input to output delay of the gate. Since a NOT gate can have only one input, it is provided as a class template taking only one template parameter which represents the input to output delay of the NOT gate.<p>
In libLCS, the cable/wire connections between modules have to be done using busses. Busses are also provided as class templates requiring one template parameter. The template parameter indicates the width (or number of lines) of the bus.<p>
Further in this section, I will go over building a trivial circuit as an illustrative example. More complicated examples can be found in the <a class="el" href="examples.html#basic_examples">basic examples</a> section.<p>
<br>
<h2><a class="anchor" name="xor_example_getting_started">
XOR gate using off-the-shelf AND, OR and NOT gates</a></h2>
We will build and simulate a circuit, which behaves like a 2-input XOR gate, using only AND, OR and NOT gates. Let <code>a</code> and <code>b</code> be inputs to our circuit. Let <code>s</code> be the output. Then, the boolean function for <code>s</code> is:<p>
<center><div class="fragment"><pre class="fragment"> s = ab' + a'b 
</pre></div></center><p>
Hence, to generate <code>s</code> from <code>a</code> and <code>b</code>, we require two 2-input AND gates, one 2-input OR gate, and two NOT gates. The circuit diagram is as follows (the small circles/bubbles represent NOT gates):<p>
<div align="center">
<img src="xor_example.jpg" alt="xor_example.jpg">
</div>
<p>
Each node in the above circuit translates in to a bus in the case of libLCS. As marked in the circuit, seven single-line busses are required to build the circuit. The first step in our program is to declare these 7 single-line bus objects. The class template to generate bus classes is defined in the header file <code>lcs/bus.h</code>. All classes in libLCS are defined in the namespace <code>lcs</code>, and so is the bus class template <code><a class="el" href="classlcs_1_1_bus.html">lcs::Bus</a></code>. We declare the busses as follows.<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classlcs_1_1_bus.html">lcs::Bus&lt;1&gt;</a> a, b, a_, b_, p1, p2, s; <span class="comment">// The bus names are same as </span>
                                     <span class="comment">// that in the diagram above.</span>
</pre></div><p>
Note the use of a template parameter of 1 in the above declaration to indicate the width of the busses being declared. After declaring the busses in the circuit, the next step is to initialise the logic gate modules in the circuit. We will first initialise the NOT gates in the circuit. The initialisation is done as follows. (The NOT gates are defined in the header file <code>lcs/not.h</code>.)<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classlcs_1_1_not.html">lcs::Not&lt;&gt;</a> ng1(a_, a), ng2(b_, b); <span class="comment">// We donot pass any template paremeters</span>
                                   <span class="comment">// to the NOT gate class as we shall use </span>
                                   <span class="comment">// the default value of 0 for the delay </span>
                                   <span class="comment">// parameter.</span>
</pre></div><p>
Notice the order of arguments being passed to the NOT gate constructors. Constructors for all the off-the-shelf gates provided in libLCS require two arguments: The output bus as the first argument, and the input bus as the second argument.<p>
Next we shall initialise the AND gate modules of our circuit. The AND gates are defined in the header file <code>lcs/and.h</code>. A two input AND gate would require a two-line bus as input. However, we have declared only single-line busses. libLCS provides an overloaded <code>operator,</code> with which one can concatenate two busses to form wider busses. We will make use of this concatenation operator to initialise the two 2-input AND gates required for our circuit.<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classlcs_1_1_and.html">lcs::And&lt;2&gt;</a> ag1(p1, (a,b_)), ag2(p2, (a_,b)); <span class="comment">// Notice the use of the template parameter of </span>
                                              <span class="comment">// 2 to denote a 2-input AND gate. The second </span>
                                              <span class="comment">// parameter is not passed to the AND gate class</span>
                                              <span class="comment">// as we shall make use of the default value of</span>
                                              <span class="comment">// zero for the delay. Also, the ',' operator is </span>
                                              <span class="comment">// used to concatenate single-line busses into </span>
                                              <span class="comment">// two-line busses.</span>
</pre></div><p>
The 2-input OR gate module is initialised in a similar manner.<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classlcs_1_1_or.html">lcs::Or&lt;2&gt;</a> og(s, (p1,p2));
</pre></div><p>
With the above OR gate initialisation, we have built our complete circuit. We now need a way to test it. For this, libLCS provides a class <code><a class="el" href="classlcs_1_1_tester.html">lcs::Tester</a></code> defined in the header file <code>lcs/tester.h</code>. It is also a class template requiring one integral template parameter. A <code><a class="el" href="classlcs_1_1_tester.html">lcs::Tester</a></code> object will have to be initialised by passing one <code><a class="el" href="classlcs_1_1_bus.html">lcs::Bus</a></code> object to the constructor (This bus object should not have been connected previously to the output port of some module). The template parameter to initialise a <code><a class="el" href="classlcs_1_1_tester.html">lcs::Tester</a></code> object should be the same as the width of the bus passed as an argument to the constructor. At every clock state change, the <code><a class="el" href="classlcs_1_1_tester.html">lcs::Tester</a></code> object feeds a different value onto the <code><a class="el" href="classlcs_1_1_bus.html">lcs::Bus</a></code> object with which it was created. The values it feeds are in sequence from 0 to 2<sup>w</sup> - 1, where w is the width of the bus with which it was created. For our circuit, we will make use of the <code><a class="el" href="classlcs_1_1_tester.html">lcs::Tester</a></code> class to feed different values to the inputs <code>a</code> and <code>b</code> as follows.<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classlcs_1_1_tester.html">lcs::Tester&lt;2&gt;</a> tester((a,b)); <span class="comment">// The template parameter 2 indicates the bus width of </span>
                              <span class="comment">// the input bus to our circuit.</span>
</pre></div><p>
Testing our circuit would not only need feeding proper inputs, we should also monitor the output of our circuit to verify the correctness. libLCS provides a class <code><a class="el" href="classlcs_1_1_change_monitor.html">lcs::ChangeMonitor</a></code> (defined in the header file <code>changeMonitor.h</code>) for this. An object of this class should be instantiated by passing a bus object and an <code>std::string</code> variable to the constructor. Then, it will monitor the bus line states and report whenever a change occurs to the line states using <code>std::string</code> variable as a name for the bus. For our circuit, we will make use of two <code><a class="el" href="classlcs_1_1_change_monitor.html">lcs::ChangeMonitor</a></code> objects: one to monitor the inputs, the other to monitor the output. This is done as follows.<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classlcs_1_1_change_monitor.html">lcs::ChangeMonitor&lt;2&gt;</a> inputMonitor((a,b), <span class="stringliteral">"Input"</span>, <a class="code" href="namespacelcs.html#e13506cb550947d35ed87fbe22493716a7672ea556e8340bd234b26bb3b8a919">lcs::DUMP_ON</a>); <span class="comment">// The template parameter 2 indicates the  </span>
                                                                  <span class="comment">// bus width of the input bus to our circuit.</span>
<a class="code" href="classlcs_1_1_change_monitor.html">lcs::ChangeMonitor&lt;1&gt;</a> outputMonitor(s, <span class="stringliteral">"Output"</span>, <a class="code" href="namespacelcs.html#e13506cb550947d35ed87fbe22493716a7672ea556e8340bd234b26bb3b8a919">lcs::DUMP_ON</a>);   <span class="comment">// The template parameter 1 indicates the bus  </span>
                                                                  <span class="comment">// width of the output bus to our circuit.</span>
</pre></div><p>
Note the additional parameter, <code><a class="el" href="namespacelcs.html#e13506cb550947d35ed87fbe22493716a7672ea556e8340bd234b26bb3b8a919">lcs::DUMP_ON</a></code>, passed to the ChangeMonitor constructors. This indicates that the states of the bus lines, which are being monitored, should be dumped into a VCD file. If you do not want them to be dumped, then you can either omit the last parameter, or pass <code><a class="el" href="namespacelcs.html#e13506cb550947d35ed87fbe2249371680420213acab4eb6894453a22b61474c">lcs::DUMP_OFF</a></code> instead of <code><a class="el" href="namespacelcs.html#e13506cb550947d35ed87fbe22493716a7672ea556e8340bd234b26bb3b8a919">lcs::DUMP_ON</a></code>.<p>
After all the circuit elements are setup, we need to start the simulation. Before we start, we also need to set the time at which the simulation should stop. This is done by a call to the static function <code><a class="el" href="classlcs_1_1_simulation.html#d2b63633aab19bd40ece3b3e661a34f6">lcs::Simulation::setStopTime</a></code>. After setting the stop time, we should start the simulation by a call to the static function <code><a class="el" href="classlcs_1_1_simulation.html#65a027482fded2293800e1736b3bbd07">lcs::Simulation::start</a></code>.<p>
The entire/complete program which simulates our circuit is as follows. It is bundeled as an example along with the latest libLCS release file.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;lcs/bus.h&gt;</span>
<span class="preprocessor">#include &lt;lcs/not.h&gt;</span>
<span class="preprocessor">#include &lt;lcs/and.h&gt;</span>
<span class="preprocessor">#include &lt;lcs/or.h&gt;</span>
<span class="preprocessor">#include &lt;lcs/tester.h&gt;</span>
<span class="preprocessor">#include &lt;lcs/simul.h&gt;</span>
<span class="preprocessor">#include &lt;lcs/changeMonitor.h&gt;</span>

<span class="keywordtype">int</span> main()
{
    <a class="code" href="classlcs_1_1_bus.html">lcs::Bus&lt;1&gt;</a> a, b, a_, b_, p1, p2, s;
    
    <a class="code" href="classlcs_1_1_not.html">lcs::Not&lt;&gt;</a> ng1(a_, a), ng2(b_, b);
    <a class="code" href="classlcs_1_1_and.html">lcs::And&lt;2&gt;</a> ag1(p1, (a,b_)), ag2(p2, (a_,b));
    <a class="code" href="classlcs_1_1_or.html">lcs::Or&lt;2&gt;</a> og(s, (p1,p2));

    <a class="code" href="classlcs_1_1_change_monitor.html">lcs::ChangeMonitor&lt;2&gt;</a> inputMonitor((a,b), <span class="stringliteral">"Input"</span>, <a class="code" href="namespacelcs.html#e13506cb550947d35ed87fbe22493716a7672ea556e8340bd234b26bb3b8a919">lcs::DUMP_ON</a>);
    <a class="code" href="classlcs_1_1_change_monitor.html">lcs::ChangeMonitor&lt;1&gt;</a> outputMonitor(s, <span class="stringliteral">"Output"</span>, <a class="code" href="namespacelcs.html#e13506cb550947d35ed87fbe22493716a7672ea556e8340bd234b26bb3b8a919">lcs::DUMP_ON</a>);

    <a class="code" href="classlcs_1_1_tester.html">lcs::Tester&lt;2&gt;</a> tester((a,b));

    <a class="code" href="classlcs_1_1_simulation.html#d2b63633aab19bd40ece3b3e661a34f6">lcs::Simulation::setStopTime</a>(1000);
    <a class="code" href="classlcs_1_1_simulation.html#65a027482fded2293800e1736b3bbd07">lcs::Simulation::start</a>();

    <span class="keywordflow">return</span> 0;
}
</pre></div><p>
When the above program is compiled and run, the following output will be obtained. (See <a class="el" href="install.html">this</a> page for information on compiling a program which uses libLCS.)<p>
<div class="fragment"><pre class="fragment">At time: 0,     Input: 00
At time: 0,     Output: 0
At time: 200,   Input: 01
At time: 200,   Output: 1
At time: 300,   Input: 10
At time: 400,   Input: 11
At time: 400,   Output: 0
</pre></div><p>
We will now try to understand what the above output means. When the circuit is turned on (ie. when that the simulation starts at time 0), the object <code>tester</code> sets the busses <code>a</code> and <code>b</code> to a value of zero each. Correspondingly, the output changes to zero from an unknown value at time 0.<p>
The object <code>tester</code> feeds sequential values at every clock state change, starting from a value of 0 . The default pulse width of the clock in libLCS is 100 system time units. Hence, a value of 0 is fed onto the input bus <code></code>(a,b) at the first clock pulse occuring at 100 time units. However, since the value was 0 even before the first clock pulse, the <code>inputMonitor</code> does not display the input states at the time of 100 units. The output corresponding to a 0 input is also 0. Hence, the <code>outputMonitor</code> does not display anything at the time of 100 units as the output has been 0 even before the first clock pulse.<p>
When the input changes to a value 01 at 200 time units, the output correspondingly changes to 1. When the input changes to 10 at 300 time units, the correct output should be 1, which is the same as that before 300 time units. Hence the change monitor does not report anything about the output as the output did not change from the previous value. When the input changes to 11 at 400 time units, the output changes to 0 from a value of 1. This is reported accoridingly as the value has changed from the previous value.<p>
<h3>The VCD file</h3>
<p>
Apart from the display of the simlation results on the standard output, we requested that the line states of the busses being monitored should be dumped into a VCD file. By default, the values are dumped into a file with name "dump.vcd" in the directory in which the simulation was executed. If one is wants a different name for the VCD file, they should set it using the function <code><a class="el" href="classlcs_1_1_simulation.html#80a176de0aa56e2c8d1c9ddb5002a220">lcs::Simulation::setDumpFileName</a></code>. The dumped VCD file should be viewed using a VCD viewer. <a href="http://www.geda.seul.org/tools/gtkwave/" class="el">GTKWave</a> is one such excellent tool which can plot the VCD wave forms. The screenshot of the GTKWave plot of the VCD file which was generated from the above simulation is as follows:<p>
<div align="center">
<img src="screenshots/xor_using_and_or_not.jpg" alt="xor_using_and_or_not.jpg">
</div>
 <hr>
<center>
	Copyright &copy 2006, 2007 Siva Chandra <br>
	<img src = "logo_small.jpg">
</center>
</body>
</html>

