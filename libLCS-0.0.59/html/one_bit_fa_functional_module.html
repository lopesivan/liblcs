<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
	<title>
		libLCS - A Logic Circuit Simulation Library in C++
	</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<body>
<br>
<center>
<table>
	<tr>
		<td>
			<img src = "logo.jpg">
		</td>
		<td>
			<h1> - A Logic Circuit Simulation Library in C++</h1>
		</td>
	</tr>
</table>
</center>

<br><br>

<div class = "tabs">
<ul>
	<li><a class = "el" href = "index.html"><span>Home</span></a></li>
	<li><a class = "el" href = "news.html"><span>News</span></a></li>
	<li><a class = "el" href = "examples.html"><span>Examples</span></a></li>
	<li><a class = "el" href = "userguide.html"><span>Userguide</span></a></li>
	<li><a class = "el" href = "devguide.html"><span>Developer Guide</span></a></li>
	<li><a class = "el" href = "download.html"><span>Download</span></a></li>
	<li><a class = "el" href = "install.html"><span>Install</span></a></li>
	<li><a class = "el" href = "links.html"><span>Links</span></a></li>
	<li><a class = "el" href = "archives.html"><span>Archives</span></a></li>
</ul>
</div>

<br><br>

<!-- Generated by Doxygen 1.4.7 -->
<h1><a class="anchor" name="one_bit_fa_functional_module">(libLCS Example) Functional module of a 1-bit fulladder</a></h1><hr>
<p>
The aim of this example is the same as that of the example presented <a class="el" href="one_bit_fa_gate_level_module.html">here</a>. However, this time we will see how to create a functional realisation of a full-adder module, unlike a gate-level realisation as in that <a class="el" href="one_bit_fa_gate_level_module.html">example</a>. The circuit diagram is as follows.<p>
<div align="center">
<img src="1fa2.jpg" alt="1fa2.jpg">
</div>
<br>
<p>
The code which implements the above circuit using functional modules of 1-bit full-adders is as follows. The implementation of the full-adder module here is the same as that of the full-adder class <code><a class="el" href="classlcs_1_1_full_adder.html">lcs::FullAdder</a></code> provided in libLCS. <br>
<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;lcs/or.h&gt;</span>
<span class="preprocessor">#include &lt;lcs/and.h&gt;</span>
<span class="preprocessor">#include &lt;lcs/not.h&gt;</span>
<span class="preprocessor">#include &lt;lcs/tester.h&gt;</span>
<span class="preprocessor">#include &lt;lcs/simul.h&gt;</span>
<span class="preprocessor">#include &lt;lcs/changeMonitor.h&gt;</span>

<span class="comment">// All classes of the libLCS are defined in the namespace lcs.</span>
<span class="keyword">using namespace </span>lcs;

<span class="keyword">using namespace </span>std;

<span class="comment">// Define a class MyFullAdder. The instances of this class will serve as</span>
<span class="comment">// 1-bit full-adder modules for our circuit.</span>
<span class="keyword">class </span>MyFullAdder : <span class="keyword">public</span> Module
{
<span class="keyword">public</span>:
    <span class="comment">// The constructor should take single line Bus&lt;1&gt; objects as inputs, one each for</span>
    <span class="comment">// the two data lines, carry input, sum output and the carry output.</span>
    MyFullAdder(<span class="keyword">const</span> Bus&lt;1&gt; &amp;S, <span class="keyword">const</span> Bus&lt;1&gt; Cout, <span class="keyword">const</span> InputBus&lt;1&gt; &amp;A,
              <span class="keyword">const</span> InputBus&lt;1&gt; &amp;B, <span class="keyword">const</span> InputBus&lt;1&gt; &amp;Cin);

    <span class="comment">// Destructor.</span>
    <span class="comment">//</span>
    ~MyFullAdder();

    <span class="comment">// This function is re-implemented from the class lcs::Module.</span>
    <span class="comment">// When state of any of the input bus lines changes, the corresponding bus</span>
    <span class="comment">// will call this function to notify the fulladder module of such a</span>
    <span class="comment">// change. This function then perform a 1-bit full binary addition of the</span>
    <span class="comment">// line states of input busses and propogate the result to the output busses.</span>
    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onStateChange(<span class="keywordtype">int</span> portId);

<span class="keyword">private</span>:
    Bus&lt;1&gt; s, cout;
    InputBus&lt;1&gt; a, b, c;
};

MyFullAdder::MyFullAdder(<span class="keyword">const</span> Bus&lt;1&gt; &amp;S, <span class="keyword">const</span> Bus&lt;1&gt; Cout, <span class="keyword">const</span> InputBus&lt;1&gt; &amp;A,
                     <span class="keyword">const</span> InputBus&lt;1&gt; &amp;B, <span class="keyword">const</span> InputBus&lt;1&gt; &amp;Cin)
         : Module(), s(S), cout(Cout), a(A), b(B), c(Cin)
{
    <span class="comment">// A functional module has to be driven by the data lines of the input busses.</span>
    <span class="comment">// In order to be driven, a module has to register itself with each of the input</span>
    <span class="comment">// busses using the drive function. If not registered, a change to the state of the data</span>
    <span class="comment">// lines of an input bus will not trigger the module to propogate the change and produce</span>
    <span class="comment">// the output.</span>
    a.notify(<span class="keyword">this</span>, LINE_STATE_CHANGE, 0);
    b.notify(<span class="keyword">this</span>, LINE_STATE_CHANGE, 0);
    c.notify(<span class="keyword">this</span>, LINE_STATE_CHANGE, 0);

    <span class="comment">// After setting up the busses, the line data should be propogated to the output so that</span>
    <span class="comment">// the output is the one corresponding to the input after the module is constructed.</span>
    onStateChange(0);
}

MyFullAdder::~MyFullAdder()
{
    <span class="comment">// When a module ceases to exist anylonger, it should notify its input busses to stop triggering</span>
    <span class="comment">// it. This is done using the lcs::InputBus::stopNotification function. If not de-registered in this</span>
    <span class="comment">// way, the input busses will try to drive a non existant module, resulting in a segmentation fault.</span>
    a.stopNotification(<span class="keyword">this</span>, LINE_STATE_CHANGE, 0);
    b.stopNotification(<span class="keyword">this</span>, LINE_STATE_CHANGE, 0);
    c.stopNotification(<span class="keyword">this</span>, LINE_STATE_CHANGE, 0);
}

<span class="keywordtype">void</span> MyFullAdder::onStateChange(<span class="keywordtype">int</span> portId)
{
    <span class="comment">// The sum and carry outputs are calculated using the overloaded bitwise operators</span>
    <span class="comment">// rather than through an ensemble of logics gates.</span>
    s = (!a[0] &amp; !b[0] &amp; c[0]) | (!a[0] &amp; b[0] &amp; !c[0]) |
                    (a[0] &amp; !b[0] &amp; !c[0]) | (a[0] &amp; b[0] &amp; c[0]) ,
    cout = (!a[0] &amp; b[0] &amp; c[0]) | (a[0] &amp; !b[0] &amp; c[0]) |
                      (a[0] &amp; b[0] &amp; !c[0]) | (a[0] &amp; b[0] &amp; c[0]) ;
}

<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
    <span class="comment">// Declaring the busses involved in out circuit.</span>
    <span class="comment">// Note that the bus c0 (the carry input to the first full-adder)</span>
    <span class="comment">// has been initialised with a value of 0 (or lcs::LOW) on its line.</span>
    Bus&lt;&gt; a1, b1, a2, b2, c0(0), S1, C1, S2, C2;

    <span class="comment">// Initialising the 1-bit full adder modules.</span>
    MyFullAdder fa1(S1, C1, a1, a2, c0), fa2(S2, C2, b1, b2, C1);

    <span class="comment">// Initialising lcs::ChangeMonitor objects which monitor the inputs and the</span>
    <span class="comment">// 3 sum bits.</span>
    ChangeMonitor&lt;4&gt; inputMonitor((a1,b1,a2,b2), <span class="stringliteral">"Input"</span>, DUMP_ON);
    ChangeMonitor&lt;3&gt; outputMonitor((S1,S2,C2), <span class="stringliteral">"Sum"</span>, DUMP_ON);

    Tester&lt;4&gt; tester((a1,b1,a2,b2));

    Simulation::setStopTime(2000); <span class="comment">// Set the time upto which the simulation should run.</span>
    Simulation::start();           <span class="comment">// Start the simulation.</span>


    <span class="keywordflow">return</span> 0;
}
</pre></div><p>
The following is the output when the following is compiled and run.<p>
<div class="fragment"><pre class="fragment">At time: 0,     Input: 0000
At time: 0,     Sum: 000
At time: 200,   Input: 0001
At time: 200,   Sum: 001
At time: 300,   Input: 0010
At time: 300,   Sum: 010
At time: 400,   Input: 0011
At time: 400,   Sum: 011
At time: 500,   Input: 0100
At time: 500,   Sum: 001
At time: 600,   Input: 0101
At time: 600,   Sum: 010
At time: 700,   Input: 0110
At time: 700,   Sum: 011
At time: 800,   Input: 0111
At time: 800,   Sum: 100
At time: 900,   Input: 1000
At time: 900,   Sum: 010
At time: 1000,  Input: 1001
At time: 1000,  Sum: 011
At time: 1100,  Input: 1010
At time: 1100,  Sum: 100
At time: 1200,  Input: 1011
At time: 1200,  Sum: 101
At time: 1300,  Input: 1100
At time: 1300,  Sum: 011
At time: 1400,  Input: 1101
At time: 1400,  Sum: 100
At time: 1500,  Input: 1110
At time: 1500,  Sum: 101
At time: 1600,  Input: 1111
At time: 1600,  Sum: 110
</pre></div><p>
Below is the screenshot of the gtkwave plot of the generated VCD file.<p>
<div align="center">
<img src="screenshots/one_bit_fa_functional_module.jpg" alt="one_bit_fa_functional_module.jpg">
</div>
 <hr>
<center>
	Copyright &copy 2006, 2007 Siva Chandra <br>
	<img src = "logo_small.jpg">
</center>
</body>
</html>

